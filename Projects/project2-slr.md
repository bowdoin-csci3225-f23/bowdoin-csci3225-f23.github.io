---
layout: default 
title: --Project 2 (SLR flooding)
nav_order: 10
---

## Project 2:  Sea-level rise flooding 

*** 
* __Assigned:__ Tuesday, September 26
* __Due:__ Friday October 6th, 4pm <--- Note: right before fall break!
* Group policy: Partner-optional

In this project you will develop a program to compute and visualize
the incremental flooding caused by sea-level rise.  

__Input:__ the name of an elevation grid, the name of the flooded grid, an SLR value and an SLR increment

Your program will read the elevation grid and compute the flooding starting at SLR =
_slr_increment_, going up by _slr_increment_, up to desired SLR value. 

For example, if the SLR value is 2 and the increment value is .5, you
will compute flooding for slr = .5, slr=1, slr=1.5 and slr=2. If the
SLR value is 3 and the increment is 1, you will compute flooding for
slr = 1, slr=2 and slr = 3.

The following examples assume _southport.asc_ with  SLR value = 3 and increment = 1.

__Output:__ A flooded grid; The SLR value that gives the largest incremental change; Some maps. 

*** 

__The flooded grid:__ The program will create a flooded grid which
records  what parts of the terrain will be flooded, and at what SLR
value. Each point in this grid  should be set to:

* 1 if the point is land  but  gets flooded at slr = 1;
* 2 is the point is land and not flooded at slr=1, but gets flooded at slr=2
* 3 if the poimt is land and not flooded at slr = 2, but gets flooded at slr = 3
* _nodata_ otherwise 

Note that a point being set to _nodata_ in the flooded grid means that
the point does not flood at the given SLR value.  This could be
because the elevation of the point is _nodata_, or because the point
is land but eitehr it is not reachable by the flood or it is reached
by the flood but its elevation is larger than the SLR value.  In other
words, the flooded grid records whether a point floods, not whether a poit is water.


__The largest incremental change:__ The program will compute the SLR
which causes the largest number of flooded points. For example,

For example, 
```
compute SLR flooding up to 3.0 (with incr=1.0)
	At rise =1.0:  flooding 2881281 new cells
	At rise =2.0:  flooding 814266 new cells
	At rise =3.0:  flooding 121239 new cells
total nb. cells flooded: 3816786 (46.92 percent)
largest flood is from slr=0.0 to slr=1.0, total 2881281 cells
```


__The maps:__ You will create the following maps: 


* map.hilshade.bmp:
  * hillshade of the elevation grid  (you have it from project 1)
* map.elev-over-hillshade.bmp:
  * elevation grid color gradient overlayed on hillshade (you have it from project 1)
* map.flooded.colordiscrete.bmp:
  * flooded grid, with discrete colors 
* map.flooded-over-hillshade.bmp:
  * flooded grid with discrete colors overlayed on hillshade



![](p2-all1.png)


__Report:__ You will write a brief report containing (1) A brief
description of the dataset you used, location, number of rows and
columns, resolution and provenance; (2) the command line to run your
code; (3) pictures of the maps generated by your code on your test
dataset.  (4) bugs and extra features. (5) Time you spent in:
thinking, Programming; Testing; documenting; total; (6) Reflection
(Prompts: how challenging did you find this project? what did you
learn by doing this project?  What did you wish you did differently?
If you worked as a team, how did that go?  What would you like to
explore further? --- you don't need to address all)



***


### Datasets


First you will want to download a dataset (for e.g. from [OpenTopo](
https://opentopography.org/) that contains coastline. If the dataset
you used for project 1 has coastline, you are all set. Otherwise you
need to download a new one.


_Test dataset:_ You can download the dataset I used to generate the
maps on this page
[here](https://tildesites.bowdoin.edu/~ltoma/DEM/southport.asc). It
covers the Southport Island off the coast of Maine, it is obtained
from Lidar, it has 2214 cols and 3674 rows, and 2m resolution.

[TO DO: UPLOAD SOUTHPORT.ASC]


### Interface 

Your code will read on the command line the name of an elevation grid,
the name of a flooded grid, an SLR value and an SLR increment. 

For example.  ``` %./slr ~/DEM/southport.asc southport-flooded.asc 3 1
```

This will flood _southport.asc_ with _slr=1, 2, 3_ and write the
output flooded grid in a file in the current directory called
_southport-flooded.asc_.


You can assume they are in this order, and therefore the name of the
elevation grid will be in _argv[1]_, the name of the flooded grid will
be in _argv[2]_, the SLR value will be in _argv[3]_ and the SLR
increment in _argv[4]_.


_Optional:_ Ideally reading the command line parameters should be done
with the _getopt()_ function, which will allow to enter these params
in arbitraty order. For example,

```
% ./slr -e ~/DEMs/southport.asc -o southport-flooded.asc -r 3  -i 1
```


### Computing the SLR flooding

For simplicity, let's assume that we want to compute flooding up to
slr=3 in increments of 1.  In class you came up with two approaches,
one recursive and one BFS-like. Because we want to flood incrementally
--- first at slr=1, then at slr=2, then at slr=3--- the BFS approach
will work more efficiently.



#### Flooding at slr=1. 

For the initial flood you will want to traverse the boundary of the
grid, find all points that are _nodata_ and put them in a queue. These
will be the "sources" of the flooding.

To compute the flooding, you will repeatedly pop a point from the
queue and check  all its neighbors: 

* if the neighbor has already been visited: there's nothing to do, continue

* if the neighbor has not been visited, and it's elevation is
 _nodata_: add it to the queue and mark it as visited (this point is
 assumed to be SEA)

* if the neighbor has not been visited and its elevation < slr:  add
  it to the queue and mark it as flooded.

When the queue is empty, flooding is done.

Note that along the way the flooded grid will be used to mark the
points that are reached by the flood (so it needs to be initialized as
_NOT_VISITED_).

At the end of the flooding process, the points can be conceptually
classified as: not visited (not reached by the flood); visited and
sea; visited and flooded; visited and not flooded (elevation above
rise). You may not need to distinguish between these different classes
but you can, if you need to.



#### Incremental flooding

After flooding with slr=1 we would like to continue with slr=2. Can
you do based on te hflooding at slr=1, without starting it all over
again?

Once you think about it, the idea is quite natural: To flood at slr=2,
we want to start from the boundary of the flood at slr=1---namely the
points that were visited and not flooded for slr=1. So if we ask
flooding at slr=1 to produce the boundary of its flood, we can use it
to start the flooding at slr=2.

And so on.

Your function to compute the flood will take as a parameter the queue
that contains the starting boundary of the flood, and will compute and
return a queue that contains the ending boundary of the flood.  This
queue will be used as the starting boundary for the next level.  It
will look something like this:


```
bnd_queue = all points on the boundary of the grid that are _nodata_
for (rise=slr_incr; rise <= slr_final; rise+= slr_incr) {

    bnd_queue = compute_flood(elev_grid, flooded_grid, rise, bnd_queue) 

} 
```


### Largest incremental flood 


As you compute each flood level,  you'll want to keep track of how many points are flooded at that level, and the overall largest flood,  something like this: 


```
compute SLR flooding up to 3.0 (with incr=1.0) 
	At rise =1.0:flooding 2881281 new cells
	At rise =2.0: flooding 814266 new cells
	At rise =3.0: flooding 121239 new cells
total nb. cells flooded: 3816786 (46.92 percent)
largest flood is from slr=0.0 to slr=1.0, total 2881281 cells ```
```



### The flooded grid


You'll want to create the flooded grid to be the same as the elevation
grid, which can be easily done using the _grid_init_from()_ function
provided in _grid.c_:

```
 //create the flooded grid 
  Grid * flooded_grid = grid_init_from(elev_grid);

  //flood
  compute_flood_incrementally(elev_grid, flooded_grid, slr_final, slr_incr); 
```

At the end you will save the flooded grid (in arcascii format) using
the function in _grid.c_:

```
  //write flooded grid 
  printf("writing %s\n", flooded_name); 
  grid_write_to_file(flooded_name, flooded_grid);
  grid_print_stats(flooded_grid);
```



### Visualizing the flooding

In addition to the hillshade of the elevation grid, and the shaded relief
(color gradient overlayed on hillshade), you will create three maps to
visualize the flooded grid:

* map.flooded.grayscale.bmp: flooded grid, in grayscale gradient

This is a standard grayscale map, and you have a function to do this
in project 1.  Call this function passing the flooded grid as an
argument.

* map.flooded.colordiscrete.bmp: flooded grid, with discrete colors

This is the same type of discrete color map based on value intervals
that you created for project 1. I did write a separate function for
this just because I wanted blue colors.

```
/* classify the values in the grid in intervals and map each
interval to a different (blue) color. Set the pixel buffer corresponding
to these colors. 
*/
void pixelbuffer_set_flooded(const Grid* grid, PixelBuffer pb)

```

A quick search for the color blue led me to [this site]
(https://html-color.codes/blue) where I picked some shades of blue,
for e.g..


```
//here I chose a map of 4 colors, need to extend it 
Color BLUE[4] = {
  {.68, .85, .90}, //light blue rgb(173,216,230) 
  {.64, .76, .68}, //cambridge blue
  {.31, .53, .97}, //royal rgb(79,134,247)
  {.15, .23, .89} //palatinate rgb(39,59,226)
} ;

```


* map.flooded-over-hillshade.bmp: flooded grid with discrete colors overlayed on hillshade

This is the same type of map you did for project1.  Consider
implementing a function to overlay two pixel buffers, like so:

```
/* overlay pb2 on top of pb1, with given transparency alpha. When
   alpha=1, show pb1; when alpha=0, show pb2. Write the output in pb1. 
*/
void pixelbuffer_overlay(PixelBuffer pb1, PixelBuffer pb2, float alpha) 
```

To overlay the flooded grid on the hillshade you can call it like so:


```
  PixelBuffer pb1, pb2;
  ...

  //create  bitmap  for hillshade 
  pixelbuffer_from_hillshade(hillshade_grid, pb1);

  //flooded grid, colors intervals discrete
  pixelbuffer_from_flooded(flooded_grid, pb2, ..);
  printf("writing map.flooded.colordiscrete\n"); 
  save_pixel_buffer_to_file(&pb2, "map.flooded.colordiscrete.bmp");

  alpha = .5;
  pixelbuffer_overlay(pb1, pb2, alpha);
  printf("writing map.flooded-over-hillshade.bmp\n"); 
  save_pixel_buffer_to_file(&pb1, "map.flooded-over-hillshade.bmp");
  ...
```



***

## Some (more) implementation details


### Dependency structure

Good coding practices recommend breaking the code into files that
encapsulate parts of the functionality, similar to how you would break
your code into classes (remember Data Structures projects).

These are the files that were given with last project, which you'll use  again: 

* stb_image_write.h
* grid.h, grid.c
* pixel_buffer.h, pixel_buffer.c 


Plan to create the following additional files: 

* map.h, map.c
* flood.hpp, flood.cpp
* slrmain.c 


__map.{h,c}:__  All functions to create bitmaps from grids. Need  to include grid.h,  pixel_buffer.h

__flood.{hpp, cpp}:__ Functions to compute the flood. Include grid.h 

__slrmain.c:__ The main() function is here.  Read parameters from
user, create grids, compute the flood and create the bitmaps. Include grid.h, map.h, flood.hpp 


Note that the flood files need to use a queue, which is a c++
structure. Currently the compiler allows that you mix c and c++ code
in a project (although you'll get a warning).

A good place to start is by copying all code from project1 over into
project2. Move all functions for creating bitmaps into _map.c and
create a header file for it, _map.h_.  Then create a file _slrmain.c_
where you add a main function --- here you will eventually call
functions to create and visualize the flooding. As you get things to
compile, start with an empty main function, and then gradually add
code to open a grid, create maps and so on.

You will also need to modify the Makefile, and here is the first part:

```
#DEBUG MODE 
CFLAGS = -m64 -Winline -g -O3 -Wall

CC = g++ $(CFLAGS)

slr:  slrmain.o flood.o map.o pixel_buffer.o grid.o 
        $(CC) -o $@ slrmain.o flood.o map.o pixel_buffer.o grid.o $(LIBS)


slrmain.o: slrmain.c flood.hpp grid.h  map.h pixel_buffer.h stb_image_write.h
        $(CC) $(CFLAGS) -o $@ -c slrmain.c 

...
###fill in the rest  
```




### Working with a queue in c++

You can use the queue in C++: 

```
#include <queue>

std::queue<point> bndqueue;
```

You can push and pop elements into/from the queue  in the usual way: 

```
while  while(!queue.empty()) {
    
    //pop the next point in the queue 
    currPoint  = queue.front();
    queue.pop();
    
} 
```

Note that  the queue is provided in C++, so the files that use queues will need to have _{.hpp, .cpp}  extensions and be compiled with g++ (rather than gcc). 






## What to turn in

* Check in your code to the github repository 
* Message me the  report. 




### Final remarks

There are many small steps to this project, and starting the day it is
assigned and making progress every day is important so that you learn
and enjoy it.  Coding can quickly become overwhelming if put off too
long.  Think one piece at a time, and remember you are not expected to
have worked on larger projects before --- this is an opportunity to
learn.


A 3000-level class means you will be independent and debug your code
mostly without help.  Use the internet as much as you can, to answer
your questions on how to do things in C/C++, syntax and so on. Write
code incrementally, in small pieces at a time, so that you always know
where teh error is coming from. Use the bitmaps and prints to know
what you are computing at all times.

Enjoy! 




